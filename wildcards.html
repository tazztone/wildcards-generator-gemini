<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Powered Wildcard Generator (v2.3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #111827; /* gray-900 */
            --bg-secondary: #1f2937; /* gray-800 */
            --bg-tertiary: #374151; /* gray-700 */
            --border-primary: #4b5563; /* gray-600 */
            --text-primary: #f3f4f6; /* gray-100 */
            --text-secondary: #d1d5db; /* gray-300 */
            --accent-primary: #4f46e5; /* indigo-600 */
            --accent-hover: #4338ca; /* indigo-700 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
        details[open] > summary .arrow-down { transform: rotate(180deg); }
        .loader {
            width: 20px; height: 20px; border: 3px solid var(--accent-primary);
            border-bottom-color: transparent; border-radius: 50%;
            display: inline-block; box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: var(--bg-secondary); }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #4a5568; }
        :focus-visible { outline: 2px solid var(--accent-primary); outline-offset: 2px; border-radius: 4px; }
        .highlight { background-color: #ffff00; color: #000000; }
        
        /* Color tints for top-level categories */
        details.category-tint-1 { background-color: rgba(79, 70, 229, 0.3); } /* indigo-600 */
        details.category-tint-2 { background-color: rgba(16, 185, 129, 0.3); } /* emerald-500 */
        details.category-tint-3 { background-color: rgba(217, 119, 6, 0.3); } /* amber-500 */
        details.category-tint-4 { background-color: rgba(220, 38, 38, 0.3); } /* red-600 */
        details.category-tint-5 { background-color: rgba(147, 51, 234, 0.3); } /* purple-600 */
        details.category-tint-6 { background-color: rgba(6, 182, 212, 0.3); } /* cyan-500 */
        details.category-tint-7 { background-color: rgba(236, 72, 153, 0.3); } /* pink-500 */
        details.category-tint-8 { background-color: rgba(234, 179, 8, 0.3); } /* yellow-500 */
        details.category-tint-9 { background-color: rgba(52, 211, 153, 0.3); } /* teal-500 */
        details.category-tint-10 { background-color: rgba(101, 116, 139, 0.3); } /* slate-400 */
        
        dialog {
            background-color: transparent; border: none; padding: 0;
            max-width: 90vw; max-height: 90vh;
        }
        dialog::backdrop {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(2px);
        }
        .sr-only {
            position: absolute; width: 1px; height: 1px;
            padding: 0; margin: -1px; overflow: hidden;
            clip: rect(0, 0, 0, 0); white-space: nowrap; border-width: 0;
        }
        .dragging { opacity: 0.5; border: 2px dashed var(--accent-primary); }
        .drag-over { background-color: var(--accent-primary) !important; opacity: 0.3; }
    </style>
</head>
<body class="antialiased">

    <div id="aria-live-region" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

    <dialog id="notification-dialog">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md text-center">
            <div id="notification-message" class="text-white mb-6 whitespace-pre-wrap"></div>
            <div id="confirmation-buttons" class="hidden justify-center gap-4">
                 <button id="confirm-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition-colors">Confirm</button>
                 <button id="cancel-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" value="cancel">Cancel</button>
            </div>
            <button id="notification-close" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition-colors" value="default">Close</button>
        </div>
    </dialog>

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl sm:text-5xl font-bold text-white mb-2">AI-Powered Wildcard Generator</h1>
            <p class="text-lg text-gray-400">Expand categories with AI. Changes are auto-saved.</p>
            
            <details class="max-w-4xl mx-auto mt-6 bg-gray-800 rounded-lg text-left">
                <summary class="flex justify-between items-center p-4 cursor-pointer">
                    <h2 class="text-xl font-semibold text-indigo-400">Global Settings</h2>
                    <span class="arrow-down transition-transform duration-300 text-indigo-400"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></span>
                </summary>
                <div class="p-4 border-t border-gray-700 space-y-6">
                    <div>
                        <label for="global-prompt" class="block text-lg font-semibold text-indigo-300 mb-2">Global System Prompt (for Wildcard Generation)</label>
                        <textarea id="global-prompt" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500 custom-scrollbar" rows="4"></textarea>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="space-y-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
                            <h3 class="text-lg font-semibold text-indigo-300">Gemini API</h3>
                            <div>
                                <label for="gemini-api-key" class="block text-sm font-medium text-gray-300 mb-1">API Key</label>
                                <div class="relative">
                                    <input type="password" id="gemini-api-key" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Enter Gemini API key" autocomplete="off">
                                    <button class="toggle-api-key-visibility absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-100" title="Show API Key">
                                        <svg class="eye-icon h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 5.943 7.523 2 12 2c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7S3.732 13.057 2.458 9c1.274-4.057 5.065-7 9.542-7z" /><path class="eye-slash" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 17L7 7" style="display: block;"/></svg>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="space-y-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
                            <h3 class="text-lg font-semibold text-indigo-300">OpenRouter API</h3>
                            <div>
                                <label for="openrouter-api-key" class="block text-sm font-medium text-gray-300 mb-1">API Key</label>
                                <div class="relative">
                                    <input type="password" id="openrouter-api-key" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Enter OpenRouter API key" autocomplete="off">
                                    <button class="toggle-api-key-visibility absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-gray-100" title="Show API Key">
                                        <svg class="eye-icon h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 5.943 7.523 2 12 2c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7S3.732 13.057 2.458 9c1.274-4.057 5.065-7 9.542-7z" /><path class="eye-slash" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 17L7 7" style="display: block;" /></svg>
                                    </button>
                                </div>
                            </div>
                            <div>
                                <label for="model-selector" class="block text-sm font-medium text-gray-300 mb-1">Model Name</label>
                                <input type="text" id="model-selector" list="model-list" class="w-full bg-gray-700 border border-gray-600 rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., openai/gpt-4o, google/gemini-flash-1.5">
                                <datalist id="model-list"></datalist>
                                <p id="model-loading-indicator" class="text-xs text-gray-400 mt-1 hidden">Loading models...</p>
                                <p id="model-error-indicator" class="text-xs text-red-400 mt-1 hidden"></p>
                            </div>
                        </div>
                    </div>
                     <div>
                        <label for="api-endpoint" class="block text-lg font-semibold text-indigo-300 mb-2">Active API Provider</label>
                        <select id="api-endpoint" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="gemini" selected>Gemini API</option>
                            <option value="openrouter">OpenRouter API</option>
                        </select>
                    </div>
                </div>
            </details>

            <div class="mt-6 text-left max-w-4xl mx-auto">
                <label for="search-wildcards" class="block text-lg font-semibold text-indigo-300 mb-2">Search Wildcards</label>
                <input type="text" id="search-wildcards" class="w-full bg-gray-800 border border-gray-600 rounded-md p-2 text-sm focus:ring-indigo-500 focus:border-indigo-500" placeholder="Search for wildcards...">
            </div>
            <div class="mt-6 flex flex-wrap justify-center items-center gap-4">
                <button id="download-all-zip" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">Download All (.zip)</button>
                <button id="export-state" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">Export State</button>
                <button id="import-state" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">Import State</button>
                <button id="undo-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">Undo (Ctrl+Z)</button>
                <button id="redo-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">Redo (Ctrl+Y)</button>
                <button id="help-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">Help</button>
                <button id="reset-btn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105">Reset All</button>
            </div>
        </header>

        <main id="wildcard-container" class="space-y-4"></main>
    </div>

    <script type="module">
        // =================================================================================
        // --- CONFIGURATION & CONSTANTS
        // =================================================================================
        const Config = {
            STORAGE_KEY: 'wildcardGeneratorState_v7',
            API_KEY_GEMINI: 'gemini_api_key_v7',
            API_KEY_OPENROUTER: 'openrouter_api_key_v7',
            HISTORY_KEY: 'wildcardGeneratorHistory_v7',
            HISTORY_LIMIT: 20,
            AUTOSAVE_INTERVAL: 500,
            SEARCH_DEBOUNCE_DELAY: 300,
            DEFAULT_SYSTEM_PROMPT: `You are a creative assistant for generating wildcards for AI image prompts. You will be given a category path, a list of existing wildcards, and optional custom instructions. Your task is to generate 20 more diverse and creative wildcards that fit the category. Do not repeat any from the existing list. Follow all custom instructions. Return ONLY the new wildcards as a JSON array of strings. Example of expected output format: ["wildcard1", "wildcard2", "wildcard3", ..., "wildcard20"] Ensure that your response is a valid JSON array of strings, containing exactly 20 unique entries relevant to the category provided.`,
            SUGGEST_ITEM_PROMPT: `You are a creative assistant helping to organize a collection of wildcards for AI image generation. You will be given a parent category path and a list of all existing item names in the entire collection. Your task is to suggest 5 new items (either sub-folders or wildcard lists) that would fit well inside the parent category: '{parentPath}'. Do not repeat any names from the provided list of existing items. Format the names to be suitable as file names (e.g., use underscores instead of spaces). Return ONLY the new names as a JSON array of strings. Example: ["new_item_1", "new_item_2"]`
        };

        // =================================================================================
        // --- UTILITY FUNCTIONS
        // =================================================================================
        const sanitize = (input) => {
            const temp = document.createElement('div');
            temp.textContent = input;
            return temp.innerHTML;
        };

        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => { clearTimeout(timeout); func(...args); };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // =================================================================================
        // --- STATE MANAGEMENT MODULE
        // =================================================================================
        const State = {
            appState: { systemPrompt: '', wildcards: {} },
            history: [],
            historyIndex: -1,
            _debounceTimeout: null,
            init() {
                this.loadHistory();
                this.loadState();
                this.initializeModelSelector();
            },
            initializeModelSelector() {
                const endpointSelect = document.getElementById('api-endpoint');
                const modelInput = document.getElementById('model-selector');
                const modelList = document.getElementById('model-list');
                const loadingIndicator = document.getElementById('model-loading-indicator');
                const errorIndicator = document.getElementById('model-error-indicator');
                
                const updateModelVisibility = () => {
                    const isRouter = endpointSelect.value === 'openrouter';
                    modelInput.closest('div').style.display = isRouter ? 'block' : 'none';
                    if (isRouter) {
                        this.fetchOpenRouterModels(modelList, loadingIndicator, errorIndicator);
                    }
                };

                endpointSelect.addEventListener('change', updateModelVisibility);
                updateModelVisibility();
            },
            async fetchOpenRouterModels(modelList, loadingIndicator, errorIndicator) {
                const apiKey = document.getElementById('openrouter-api-key').value.trim();
                if (!apiKey) {
                    errorIndicator.textContent = 'Please enter an OpenRouter API key to load models.';
                    errorIndicator.classList.remove('hidden');
                    return;
                }
                
                loadingIndicator.classList.remove('hidden');
                errorIndicator.classList.add('hidden');
                
                try {
                    const response = await fetch('https://openrouter.ai/api/v1/models');
                    if (!response.ok) throw new Error(`Failed to fetch models: ${response.statusText}`);
                    
                    const { data } = await response.json();
                    modelList.innerHTML = '';
                    if (data && data.length > 0) {
                        data.sort((a, b) => a.id.localeCompare(b.id));
                        data.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model.id;
                            modelList.appendChild(option);
                        });
                    } else {
                        errorIndicator.textContent = 'No models available.';
                        errorIndicator.classList.remove('hidden');
                    }
                } catch (error) {
                    errorIndicator.textContent = `Error: ${error.message}`;
                    errorIndicator.classList.remove('hidden');
                } finally {
                    loadingIndicator.classList.add('hidden');
                }
            },
            loadState() {
                try {
                    const savedState = localStorage.getItem(Config.STORAGE_KEY);
                    if (savedState) {
                        const parsed = JSON.parse(savedState);
                        if (parsed.systemPrompt && parsed.wildcards && Object.keys(parsed.wildcards).length > 0) {
                            this.appState = parsed;
                            return;
                        }
                    }
                } catch (error) { console.error("Failed to load state, falling back to default.", error); }
                
                this.resetState(false); // Don't show notification on initial load
            },
            saveState(immediate = false) {
                if (immediate) {
                    this._save();
                    UI.announce("State saved.");
                } else {
                    clearTimeout(this._debounceTimeout);
                    this._debounceTimeout = setTimeout(() => {
                        this._save();
                        UI.announce("State auto-saved.");
                    }, Config.AUTOSAVE_INTERVAL);
                }
            },
            _save() { try { localStorage.setItem(Config.STORAGE_KEY, JSON.stringify(this.appState)); } catch (e) { console.error("Failed to save state", e); } },
            resetState(notify = true) {
                const performReset = (data) => {
                    this.appState.wildcards = data;
                    this.appState.systemPrompt = Config.DEFAULT_SYSTEM_PROMPT;
                    this.saveState(true);
                    this.clearHistory();
                    this.saveStateToHistory();
                    UI.renderAll();
                    if (notify) UI.showNotification('All categories have been reset.');
                };

                fetch('initial-data.json')
                    .then(response => {
                        if (!response.ok) throw new Error('Network response was not ok');
                        return response.json();
                    })
                    .then(data => performReset(data))
                    .catch(error => {
                        console.error("Failed to load initial-data.json, resetting to an empty state:", error);
                        performReset({}); // Fallback to an empty object
                        if (notify) UI.showNotification("Could not load default data. Resetting to a blank slate.");
                    });
            },
            saveStateToHistory() {
                if (this.historyIndex < this.history.length - 1) this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(JSON.stringify(this.appState));
                if (this.history.length > Config.HISTORY_LIMIT) this.history.shift();
                this.historyIndex = this.history.length - 1;
                this._saveHistory();
            },
            loadHistory() {
                try {
                    const savedHistory = localStorage.getItem(Config.HISTORY_KEY);
                    const savedIndex = localStorage.getItem(`historyIndex_${Config.HISTORY_KEY}`);
                    if (savedHistory) { this.history = JSON.parse(savedHistory); this.historyIndex = savedIndex ? parseInt(savedIndex, 10) : this.history.length - 1; }
                    else this.saveStateToHistory();
                } catch (e) { console.error("Failed to load history", e); this.history = []; this.historyIndex = -1; }
            },
            _saveHistory() { localStorage.setItem(Config.HISTORY_KEY, JSON.stringify(this.history)); localStorage.setItem(`historyIndex_${Config.HISTORY_KEY}`, this.historyIndex); },
            clearHistory() { this.history = []; this.historyIndex = -1; localStorage.removeItem(Config.HISTORY_KEY); localStorage.removeItem(`historyIndex_${Config.HISTORY_KEY}`); },
            undo() { if (this.historyIndex > 0) { this.historyIndex--; this.appState = JSON.parse(this.history[this.historyIndex]); this._saveHistory(); this.saveState(true); return true; } return false; },
            redo() { if (this.historyIndex < this.history.length - 1) { this.historyIndex++; this.appState = JSON.parse(this.history[this.historyIndex]); this._saveHistory(); this.saveState(true); return true; } return false; }
        };

        // =================================================================================
        // --- API MODULE
        // =================================================================================
        const Api = {
            activeController: null,
            async generateWildcards(globalPrompt, categoryPath, existingWords, customInstructions) {
                if (this.activeController) this.activeController.abort();
                this.activeController = new AbortController();
                try {
                    const readablePath = categoryPath.replace(/\//g, ' > ').replace(/_/g, ' ');
                    const userPrompt = `Category Path: '${readablePath}'\nExisting Wildcards: ${existingWords.slice(0, 50).join(', ')}\nCustom Instructions: "${customInstructions.trim()}"`;
                    const generationConfig = { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "STRING" } } };
                    
                    const { url, payload, headers } = this._prepareRequest(globalPrompt, userPrompt, generationConfig);
                    
                    const response = await fetch(url, { method: 'POST', headers, body: JSON.stringify(payload), signal: AbortSignal.any([this.activeController.signal, AbortSignal.timeout(30000)]) });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API request failed: ${response.status} - ${errorText}`);
                    }
                    return this._parseResponse(await response.json());
                } catch (error) {
                    if (error.name === 'AbortError') throw new Error("Request timed out or was aborted.");
                    console.error("Error calling LLM API:", error);
                    throw error;
                } finally {
                    this.activeController = null;
                }
            },
            async suggestItems(parentPath, allExistingKeys) {
                if (this.activeController) this.activeController.abort();
                this.activeController = new AbortController();
                try {
                    const readablePath = parentPath ? parentPath.replace(/\//g, ' > ').replace(/_/g, ' ') : 'Top-Level';
                    const globalPrompt = Config.SUGGEST_ITEM_PROMPT.replace('{parentPath}', readablePath);
                    const userPrompt = `All Existing Item Names: ${allExistingKeys.join(', ')}`;
                    const generationConfig = { responseMimeType: "application/json", responseSchema: { type: "ARRAY", items: { type: "STRING" } } };

                    const { url, payload, headers } = this._prepareRequest(globalPrompt, userPrompt, generationConfig);

                    const response = await fetch(url, { method: 'POST', headers, body: JSON.stringify(payload), signal: AbortSignal.any([this.activeController.signal, AbortSignal.timeout(30000)]) });
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API request failed: ${response.status} - ${errorText}`);
                    }
                    return this._parseResponse(await response.json());
                } catch (error) {
                    if (error.name === 'AbortError') throw new Error("Request timed out or was aborted.");
                    console.error("Error calling LLM API for suggestions:", error);
                    throw error;
                } finally {
                    this.activeController = null;
                }
            },
            _prepareRequest(globalPrompt, userPrompt, generationConfig = {}) {
                const endpoint = document.getElementById('api-endpoint').value;
                let apiKey, url, payload, headers = { 'Content-Type': 'application/json' };

                if (endpoint === 'gemini') {
                    apiKey = document.getElementById('gemini-api-key').value.trim();
                    if (!apiKey) throw new Error("Gemini API key is not provided.");
                    url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                    payload = {
                        contents: [
                            { role: "user", parts: [{ text: globalPrompt }] },
                            { role: "model", parts: [{ text: "Understood." }] },
                            { role: "user", parts: [{ text: userPrompt }] }
                        ],
                        generationConfig: generationConfig
                    };
                } else if (endpoint === 'openrouter') {
                    apiKey = document.getElementById('openrouter-api-key').value.trim();
                    if (!apiKey) throw new Error("OpenRouter API key is not provided.");
                    const model = document.getElementById('model-selector').value.trim() || "openai/gpt-4o";
                    url = `https://openrouter.ai/api/v1/chat/completions`;
                    headers['Authorization'] = `Bearer ${apiKey}`;
                    payload = {
                        model,
                        messages: [
                            { role: "system", content: globalPrompt },
                            { role: "user", content: userPrompt }
                        ],
                        response_format: { type: "json_object" }
                    };
                } else {
                    throw new Error("Invalid API endpoint.");
                }
                return { url, payload, headers };
            },
            _parseResponse(result) {
                const endpoint = document.getElementById('api-endpoint').value;
                try {
                    if (endpoint === 'gemini') return JSON.parse(result.candidates[0].content.parts[0].text);
                    if (endpoint === 'openrouter') {
                        let contentStr = result.choices[0].message.content;
                        const match = /```(?:json)?\s*([\s\S]*?)\s*```/.exec(contentStr);
                        if (match) contentStr = match[1];
                        const content = JSON.parse(contentStr);
                        return Array.isArray(content) ? content : content.wildcards || content.categories || content.items || [];
                    }
                    return [];
                } catch (e) {
                    console.error("Failed to parse AI response:", result, e);
                    throw new Error(`The AI returned a malformed response. Error: ${e.message}`);
                }
            }
        };

        // =================================================================================
        // --- UI MODULE (with Refactored Rendering)
        // =================================================================================
        const UI = {
            elements: {},
            init() {
                this.elements = {
                    container: document.getElementById('wildcard-container'),
                    globalPrompt: document.getElementById('global-prompt'),
                    geminiApiKey: document.getElementById('gemini-api-key'),
                    openrouterApiKey: document.getElementById('openrouter-api-key'),
                    apiEndpoint: document.getElementById('api-endpoint'),
                    search: document.getElementById('search-wildcards'),
                    dialog: document.getElementById('notification-dialog'),
                    dialogMessage: document.getElementById('notification-message'),
                    dialogConfirm: document.getElementById('confirm-btn'),
                    dialogCancel: document.getElementById('cancel-btn'),
                    dialogClose: document.getElementById('notification-close'),
                    dialogConfirmButtons: document.getElementById('confirmation-buttons'),
                    ariaLive: document.getElementById('aria-live-region')
                };
                this.elements.dialog.addEventListener('close', () => {
                    const input = this.elements.dialog.querySelector('input');
                    if (input) input.remove();
                });
            },
            renderAll() {
                const { wildcards, systemPrompt } = State.appState;
                this.elements.globalPrompt.value = systemPrompt;
                this.elements.geminiApiKey.value = localStorage.getItem(Config.API_KEY_GEMINI) || '';
                this.elements.openrouterApiKey.value = localStorage.getItem(Config.API_KEY_OPENROUTER) || '';
                
                const openPaths = [...this.elements.container.querySelectorAll('details[open]')].map(d => d.dataset.path);

                this.elements.container.innerHTML = '';
                const fragment = document.createDocumentFragment();
                const sortedKeys = Object.keys(wildcards).sort();
                
                sortedKeys.forEach((key, index) => {
                    const element = this.createCategoryElement(key, wildcards[key], 0, key, index);
                    fragment.appendChild(element);
                });
                fragment.appendChild(this.createPlaceholderCategory());
                this.elements.container.appendChild(fragment);

                openPaths.forEach(path => {
                    const el = this.elements.container.querySelector(`details[data-path="${path}"]`);
                    if (el) el.open = true;
                });
            },
            createCategoryElement(name, data, level, path, index) {
                const element = document.createElement('details');
                element.className = `bg-gray-800 rounded-lg shadow-md group ${level > 0 ? 'ml-4 mt-2' : ''}`;
                if (level === 0) {
                     element.classList.add(`category-tint-${(index % 10) + 1}`);
                }
                element.dataset.path = path;
                element.draggable = true;
                
                element.innerHTML = this.getCategoryFolderHtml(name, path);
                const contentWrapper = element.querySelector('.content-wrapper');
                
                const sortedKeys = Object.keys(data).sort();
                if (sortedKeys.length === 0) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'text-gray-500 text-center p-4 italic';
                    placeholder.textContent = 'This category is empty. Drag items here or add a new one.';
                    contentWrapper.appendChild(placeholder);
                    return element;
                }

                const leafNodes = [];
                const nonLeafNodes = [];

                for (const key of sortedKeys) {
                    const childData = data[key];
                    const childIsLeaf = childData && typeof childData === 'object' && Array.isArray(childData.wildcards);
                    const childPath = `${path}/${key}`;

                    if (childIsLeaf) {
                        leafNodes.push(this.createWildcardCardElement(key, childData, level + 1, childPath));
                    } else {
                        nonLeafNodes.push(this.createCategoryElement(key, childData, level + 1, childPath, 0));
                    }
                }

                nonLeafNodes.forEach(node => contentWrapper.appendChild(node));
                
                if (leafNodes.length > 0) {
                    const gridWrapper = document.createElement('div');
                    gridWrapper.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 w-full';
                    leafNodes.forEach(node => gridWrapper.appendChild(node));
                    contentWrapper.appendChild(gridWrapper);
                }
                
                return element;
            },
            createWildcardCardElement(name, data, level, path) {
                const element = document.createElement('div');
                element.className = `bg-gray-700/50 p-4 rounded-lg flex flex-col`;
                element.dataset.path = path;
                element.draggable = true;
                element.innerHTML = this.getWildcardCardHtml(name, data, path);
                return element;
            },
            getCategoryFolderHtml(name, path) {
                return `
                    <summary class="flex justify-between items-center p-4 cursor-pointer">
                        <div class="flex items-center gap-3 flex-wrap">
                            <h2 class="text-xl font-semibold text-indigo-400"><span contenteditable="true" class="outline-none focus:bg-indigo-400/50 rounded px-1">${sanitize(name.replace(/_/g, ' '))}</span></h2>
                            <button class="delete-btn text-red-400 hover:text-red-300 font-bold text-xl leading-none" title="Delete this category">&times;</button>
                        </div>
                        <div class="flex items-center gap-2">
                            <button class="suggest-subcategory-btn bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-2 text-sm rounded-md" title="Suggest new items for this category">Suggest</button>
                            <button class="add-subcategory-btn bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-2 text-sm rounded-md" title="Add new sub-category">+</button>
                            <span class="arrow-down transition-transform duration-300 text-indigo-400"><svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg></span>
                        </div>
                    </summary>
                    <div class="content-wrapper p-4 border-t border-gray-700 grid grid-cols-1 gap-4"></div>`;
            },
            getWildcardCardHtml(name, data, path) {
                return `
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-bold text-lg text-gray-100"><span contenteditable="true" class="outline-none focus:bg-indigo-400/50 rounded px-1">${sanitize(name.replace(/_/g, ' '))}</span> <span class="text-gray-400 text-sm ml-2">(${(data.wildcards || []).length})</span></h3>
                        <button class="delete-btn text-red-400 hover:text-red-300 font-bold text-xl leading-none" title="Delete this card">&times;</button>
                    </div>
                    <input type="text" value="${sanitize(data.instruction || '')}" class="custom-instructions-input bg-gray-800 text-sm border border-gray-600 rounded-md px-2 py-1 w-full my-2 focus:ring-indigo-500 focus:border-indigo-500" placeholder="Custom generation instructions...">
                    <div class="chip-container custom-scrollbar flex flex-wrap gap-2 bg-gray-800 rounded-md p-2 w-full border border-gray-600 overflow-y-auto" style="height: 150px;">
                        ${(data.wildcards || []).map((wc, i) => this.createChip(wc, i)).join('')}
                    </div>
                    <div class="flex gap-2 mt-2">
                        <input type="text" placeholder="Add new wildcard..." class="add-wildcard-input flex-grow bg-gray-800 border border-gray-600 rounded-md px-2 py-1 text-sm">
                        <button class="add-wildcard-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold px-3 rounded-md">+</button>
                    </div>
                    <div class="flex justify-between items-center mt-3 flex-wrap gap-2">
                        <button class="generate-btn bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-bold py-2 px-3 rounded-md flex items-center gap-2"><span class="btn-text">Generate More</span><div class="loader hidden"></div></button>
                        <button class="copy-btn text-gray-400 hover:text-white" title="Copy all wildcards"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                        <button class="select-all-btn bg-gray-600 hover:bg-gray-700 text-white text-xs font-bold py-2 px-3 rounded-md">Select All</button>
                        <button class="batch-delete-btn bg-red-600 hover:bg-red-700 text-white text-xs font-bold py-2 px-3 rounded-md">Delete Selected</button>
                    </div>`;
            },
            createPlaceholderCategory() {
                const placeholderWrapper = document.createElement('div');
                placeholderWrapper.className = 'bg-gray-800 rounded-lg shadow-md mt-4';
                placeholderWrapper.innerHTML = `
                    <div class="p-4 flex flex-wrap justify-between items-center gap-4">
                        <h2 class="text-xl sm:text-2xl font-semibold text-indigo-400">Add New Top-Level Category</h2>
                        <div class="flex items-center gap-2">
                            <button id="suggest-toplevel-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-md" title="Suggest new categories using AI">Suggest</button>
                            <button id="add-category-placeholder-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md" title="Add new category">+</button>
                        </div>
                    </div>`;
                return placeholderWrapper;
            },
            createChip(wildcard, index) { return `<div class="chip bg-indigo-500/50 text-white text-sm px-2 py-1 rounded-md flex items-center gap-2 whitespace-nowrap" data-index="${index}"><input type="checkbox" class="batch-select bg-gray-700 border-gray-500 text-indigo-600 focus:ring-indigo-500"><span contenteditable="true" class="outline-none focus:bg-indigo-400/50 rounded px-1">${sanitize(wildcard)}</span></div>`; },
            updateCardByPath(path) {
                const card = this.elements.container.querySelector(`[data-path="${path}"]`);
                if (!card) return;
                const data = App.getObjectByPath(path);
                if (!data) return;
                card.querySelector('h3 .text-gray-400').textContent = `(${(data.wildcards || []).length})`;
                card.querySelector('.chip-container').innerHTML = (data.wildcards || []).map((wc, i) => this.createChip(wc, i)).join('');
            },
            showNotification(message, isConfirmation = false, onConfirm = null, withInput = false) {
                this.elements.dialogMessage.innerHTML = '';
                let inputElement = null;

                if (message.trim().startsWith('<')) {
                    this.elements.dialogMessage.innerHTML = message;
                } else {
                    const p = document.createElement('p');
                    p.textContent = message;
                    this.elements.dialogMessage.appendChild(p);
                }

                if (withInput) {
                    inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.className = 'bg-gray-900 border border-gray-600 rounded-md p-2 text-sm w-full mt-4';
                    this.elements.dialogMessage.appendChild(inputElement);
                    inputElement.focus();
                }
                
                this.elements.dialogConfirmButtons.classList.toggle('hidden', !isConfirmation);
                this.elements.dialogClose.classList.toggle('hidden', isConfirmation);
                this.elements.dialog.showModal();
                
                this.elements.dialogConfirm.onclick = () => { if (onConfirm) onConfirm(inputElement ? inputElement.value : null); this.elements.dialog.close('confirm'); };
                this.elements.dialogCancel.onclick = () => this.elements.dialog.close('cancel');
                this.elements.dialogClose.onclick = () => this.elements.dialog.close('close');
            },
            announce(message) { this.elements.ariaLive.textContent = message; },
            toggleGenerateButton(btn, isLoading) {
                const btnText = btn.querySelector('.btn-text'); const loader = btn.querySelector('.loader');
                btnText.textContent = isLoading ? 'Cancel' : 'Generate More';
                loader.classList.toggle('hidden', !isLoading);
                btn.classList.toggle('bg-indigo-600', !isLoading); btn.classList.toggle('hover:bg-indigo-700', !isLoading);
                btn.classList.toggle('bg-yellow-600', isLoading); btn.classList.toggle('hover:bg-yellow-700', isLoading);
            }
        };

        // =================================================================================
        // --- MAIN APPLICATION MODULE (CONTROLLER)
        // =================================================================================
        const App = {
            draggedPath: null,
            init() {
                UI.init();
                State.init();
                UI.renderAll();
                this.bindEventListeners();
                this.debouncedSearch = debounce(this.handleSearch, Config.SEARCH_DEBOUNCE_DELAY);
                this.loadApiKeysFromEnv();
            },
            async loadApiKeysFromEnv() {
                try {
                    const geminiResponse = await fetch('API_GEMINI.ENV');
                    if (geminiResponse.ok) {
                        const geminiKey = (await geminiResponse.text()).trim();
                        document.getElementById('gemini-api-key').value = geminiKey;
                        localStorage.setItem(Config.API_KEY_GEMINI, geminiKey);
                    } else {
                        console.info('API_GEMINI.ENV not found. Using localStorage.');
                    }
                } catch (error) {
                    console.info('Could not fetch Gemini API key:', error);
                }

                try {
                    const openRouterResponse = await fetch('API_OPENROUTER.ENV');
                    if (openRouterResponse.ok) {
                        const openRouterKey = (await openRouterResponse.text()).trim();
                        document.getElementById('openrouter-api-key').value = openRouterKey;
                        localStorage.setItem(Config.API_KEY_OPENROUTER, openRouterKey);
                        State.initializeModelSelector();
                    } else {
                         console.info('API_OPENROUTER.ENV not found. Using localStorage.');
                    }
                } catch (error) {
                    console.info('Could not fetch OpenRouter API key:', error);
                }
            },
            bindEventListeners() {
                UI.elements.globalPrompt.addEventListener('input', e => { State.appState.systemPrompt = e.target.value; State.saveState(); });
                UI.elements.geminiApiKey.addEventListener('input', e => localStorage.setItem(Config.API_KEY_GEMINI, e.target.value.trim()));
                UI.elements.openrouterApiKey.addEventListener('input', e => {
                    localStorage.setItem(Config.API_KEY_OPENROUTER, e.target.value.trim());
                    State.initializeModelSelector();
                });

                document.querySelectorAll('.toggle-api-key-visibility').forEach(button => {
                    button.addEventListener('click', () => {
                        const input = button.previousElementSibling;
                        const eyeSlash = button.querySelector('.eye-slash');
                        const isHidden = input.type === 'password';
                        input.type = isHidden ? 'text' : 'password';
                        eyeSlash.style.display = isHidden ? 'none' : 'block';
                        button.title = isHidden ? 'Hide API Key' : 'Show API Key';
                    });
                });

                UI.elements.search.addEventListener('input', e => this.debouncedSearch(e.target.value));
                document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));
                
                document.addEventListener('click', e => {
                    if (e.target.matches('#add-category-placeholder-btn')) this.handleAddNewCategory();
                    if (e.target.matches('#suggest-toplevel-btn')) this.handleSuggestItems(null);
                    if (e.target.matches('#download-all-zip')) this.handleDownloadZip();
                    if (e.target.matches('#export-state')) this.handleExportState();
                    if (e.target.matches('#import-state')) this.handleImportState();
                    if (e.target.matches('#undo-btn')) this.handleUndo();
                    if (e.target.matches('#redo-btn')) this.handleRedo();
                    if (e.target.matches('#help-btn')) this.handleHelp();
                    if (e.target.matches('#reset-btn')) State.resetState();
                });

                UI.elements.container.addEventListener('click', this.handleContainerClick.bind(this));
                UI.elements.container.addEventListener('input', e => { if (e.target.matches('.custom-instructions-input')) { const path = e.target.closest('[data-path]').dataset.path; this.getObjectByPath(path).instruction = e.target.value; State.saveState(); } });
                UI.elements.container.addEventListener('keydown', e => { if (e.key === 'Enter') { if (e.target.matches('.add-wildcard-input')) { e.preventDefault(); e.target.nextElementSibling.click(); } if (e.target.matches('[contenteditable="true"]')) { e.preventDefault(); e.target.blur(); } } });
                UI.elements.container.addEventListener('blur', e => { if (e.target.matches('[contenteditable="true"]')) this.handleContentEditableBlur(e.target); }, true);
                
                const container = UI.elements.container;
                container.addEventListener('dragstart', this.handleDragStart.bind(this));
                container.addEventListener('dragover', this.handleDragOver.bind(this));
                container.addEventListener('dragleave', this.handleDragLeave.bind(this));
                container.addEventListener('drop', this.handleDrop.bind(this));
                container.addEventListener('dragend', this.handleDragEnd.bind(this));
            },
            getAllKeys(obj) {
                const keys = [];
                function recurse(currentObj) {
                    for (const key in currentObj) {
                        keys.push(key);
                        const value = currentObj[key];
                        if (typeof value === 'object' && !Array.isArray(value.wildcards)) {
                            recurse(value);
                        }
                    }
                }
                recurse(obj);
                return keys;
            },
            getObjectByPath(path) {
                if (!path) return State.appState.wildcards;
                return path.split('/').reduce((obj, key) => (obj && obj[key] !== undefined) ? obj[key] : undefined, State.appState.wildcards);
            },
            getParentObjectByPath(path) {
                if (!path || !path.includes('/')) return State.appState.wildcards;
                const parentPath = path.substring(0, path.lastIndexOf('/'));
                return this.getObjectByPath(parentPath);
            },
            handleKeyboardShortcuts(e) {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key.toLowerCase()) {
                        case 's': e.preventDefault(); State.saveState(true); break;
                        case 'z': e.preventDefault(); this.handleUndo(); break;
                        case 'y': e.preventDefault(); this.handleRedo(); break;
                    }
                }
            },
            handleContainerClick(e) {
                const target = e.target;
                const pathElement = target.closest('[data-path]');
                if (!pathElement && !target.closest('.suggest-subcategory-btn')) return;

                const path = pathElement ? pathElement.dataset.path : null;

                if (target.closest('.add-subcategory-btn')) { e.preventDefault(); this.handleAddSubCategory(path); return; }
                if (target.closest('.suggest-subcategory-btn')) { e.preventDefault(); this.handleSuggestItems(path); return; }
                if (target.closest('.delete-btn')) { e.preventDefault(); this.handleDelete(path); return; }
                
                if (target.closest('.generate-btn')) {
                    const endpoint = document.getElementById('api-endpoint').value;
                    const key = endpoint === 'gemini' ? UI.elements.geminiApiKey.value : UI.elements.openrouterApiKey.value;
                    if (!key.trim()) {
                        UI.showNotification(`Please add an API key for ${endpoint === 'gemini' ? 'Gemini' : 'OpenRouter'} in the Global Settings to use this feature.`);
                        return;
                    }
                    this.handleGenerate(target.closest('.generate-btn'), path);
                }
                if (target.closest('.copy-btn')) this.handleCopy(path);
                if (target.closest('.add-wildcard-btn')) this.handleAddWildcard(pathElement, path);
                if (target.closest('.batch-delete-btn')) this.handleBatchDelete(pathElement, path);
                if (target.closest('.select-all-btn')) this.handleSelectAll(pathElement, target.closest('.select-all-btn'));
            },
            handleContentEditableBlur(target) {
                const element = target.closest('[data-path]');
                if (!element) return;

                const path = element.dataset.path;
                const isChip = target.closest('.chip');
                
                if (isChip) {
                    const index = parseInt(isChip.dataset.index, 10);
                    const dataObject = this.getObjectByPath(path);
                    const originalText = dataObject.wildcards[index];
                    const newText = target.textContent.trim();
                    if (newText && newText !== originalText) {
                        State.saveStateToHistory();
                        dataObject.wildcards[index] = newText;
                        State.saveState();
                    } else {
                        target.textContent = originalText;
                    }
                } else { // It's a category/card title
                    const parentObject = this.getParentObjectByPath(path);
                    const oldKey = path.split('/').pop();
                    const oldText = oldKey.replace(/_/g, ' ');
                    const newText = target.textContent.trim();
                    
                    if (!newText || newText === oldText) {
                         target.textContent = oldText; // Revert if empty or unchanged
                         return;
                    }
                    const newKey = newText.replace(/\s+/g, '_');

                    if (parentObject[newKey]) {
                        UI.showNotification(`An item named "${newText}" already exists here.`);
                        target.textContent = oldText;
                        return;
                    }
                    State.saveStateToHistory();
                    const data = parentObject[oldKey];
                    delete parentObject[oldKey];
                    parentObject[newKey] = data;
                    State.saveState(true);
                    UI.renderAll();
                    UI.announce(`Renamed "${oldText}" to "${newText}".`);
                }
            },
            async handleGenerate(btn, path) {
                if (Api.activeController) { Api.activeController.abort(); UI.toggleGenerateButton(btn, false); return; }
                UI.toggleGenerateButton(btn, true);
                try {
                    const dataObject = this.getObjectByPath(path);
                    const newWildcards = await Api.generateWildcards(State.appState.systemPrompt, path, dataObject.wildcards, dataObject.instruction);
                    if (newWildcards) {
                        State.saveStateToHistory();
                        const existingSet = new Set(dataObject.wildcards);
                        const uniqueNew = newWildcards.filter(w => w && !existingSet.has(w));
                        dataObject.wildcards.push(...uniqueNew);
                        State.saveState(true); UI.updateCardByPath(path);
                        UI.announce(`Added ${uniqueNew.length} new wildcards.`);
                    }
                } catch (error) {
                    console.error("Generation error:", error);
                    UI.showNotification(`Error: ${error.message || "An unknown error occurred."}`);
                } finally {
                    if (!Api.activeController) UI.toggleGenerateButton(btn, false);
                }
            },
            async handleSuggestItems(path) {
                const endpoint = document.getElementById('api-endpoint').value;
                const key = endpoint === 'gemini' ? UI.elements.geminiApiKey.value : UI.elements.openrouterApiKey.value;
                if (!key.trim()) {
                    UI.showNotification(`Please add an API key for ${endpoint === 'gemini' ? 'Gemini' : 'OpenRouter'} in the Global Settings to use this feature.`);
                    return;
                }

                const allKeys = this.getAllKeys(State.appState.wildcards);
                UI.showNotification('Asking AI for suggestions...');
                
                try {
                    const suggestions = await Api.suggestItems(path, allKeys);
                    if (!suggestions || suggestions.length === 0) {
                        UI.showNotification('The AI did not return any suggestions. Please try again.');
                        return;
                    }

                    const suggestionHtml = `
                        <p class="mb-4 text-left">Here are some suggested items. Select the ones you want to add:</p>
                        <div id="suggestion-list" class="space-y-2 text-left max-h-60 overflow-y-auto custom-scrollbar p-2 bg-gray-900 rounded-md border border-gray-600">
                            ${suggestions.map((s, i) => `
                                <label for="suggestion-${i}" class="flex items-center p-2 rounded-md hover:bg-gray-700 cursor-pointer">
                                    <input type="checkbox" id="suggestion-${i}" value="${sanitize(s)}" class="suggestion-checkbox h-4 w-4 bg-gray-700 border-gray-500 text-indigo-600 focus:ring-indigo-500 rounded mr-3" checked>
                                    <span>${sanitize(s.replace(/_/g, ' '))}</span>
                                </label>
                            `).join('')}
                        </div>
                    `;

                    UI.showNotification(suggestionHtml, true, () => {
                        const selected = Array.from(document.querySelectorAll('.suggestion-checkbox:checked')).map(cb => cb.value);
                        if (selected.length > 0) {
                            State.saveStateToHistory();
                            let addedCount = 0;
                            const parentObject = this.getObjectByPath(path);

                            selected.forEach(name => {
                                const sanitizedName = name.trim().replace(/\s+/g, '_');
                                if (sanitizedName && !parentObject[sanitizedName]) {
                                    // For now, all suggested items are folders. A more complex UI could ask.
                                    parentObject[sanitizedName] = {};
                                    addedCount++;
                                }
                            });
                            if (addedCount > 0) {
                                State.saveState(true);
                                UI.renderAll();
                                UI.announce(`${addedCount} new items added.`);
                            }
                        }
                    });

                } catch (error) {
                    console.error("Suggestion error:", error);
                    UI.showNotification(`Error: ${error.message || "An unknown error occurred."}`);
                }
            },
            handleCopy(path) { const content = this.getObjectByPath(path).wildcards.join('\n'); navigator.clipboard.writeText(content).then(() => UI.showNotification('Copied!')).catch(() => UI.showNotification('Failed to copy.')); },
            handleAddWildcard(card, path) {
                const input = card.querySelector('.add-wildcard-input'); const value = input.value.trim();
                if (value) { State.saveStateToHistory(); this.getObjectByPath(path).wildcards.push(value); State.saveState(true); UI.updateCardByPath(path); input.value = ''; input.focus(); }
            },
            handleBatchDelete(card, path) {
                const checkboxes = card.querySelectorAll('.batch-select:checked'); if (checkboxes.length === 0) return;
                State.saveStateToHistory();
                const indicesToDelete = Array.from(checkboxes).map(cb => parseInt(cb.closest('.chip').dataset.index, 10));
                const dataObject = this.getObjectByPath(path);
                dataObject.wildcards = dataObject.wildcards.filter((_, i) => !indicesToDelete.includes(i));
                State.saveState(true); UI.updateCardByPath(path); UI.announce(`Deleted ${indicesToDelete.length} wildcards.`);
            },
            handleDelete(path) {
                const keyToDelete = path.split('/').pop();
                const parentObject = this.getParentObjectByPath(path);
                UI.showNotification(`Delete "${keyToDelete.replace(/_/g, ' ')}"?`, true, () => {
                    State.saveStateToHistory();
                    delete parentObject[keyToDelete];
                    State.saveState(true);
                    UI.renderAll();
                    UI.announce(`Item deleted.`);
                });
            },
            handleSelectAll(card, button) { const checkboxes = card.querySelectorAll('.batch-select'); const isSelectAll = button.textContent === 'Select All'; checkboxes.forEach(cb => cb.checked = isSelectAll); button.textContent = isSelectAll ? 'Deselect All' : 'Select All'; },
            handleAddNewCategory() {
                UI.showNotification('Enter new top-level category name:', true, (name) => {
                    if (name && name.trim()) {
                        const sanitizedName = name.trim().replace(/\s+/g, '_');
                        if (State.appState.wildcards[sanitizedName]) { UI.showNotification(`Category "${sanitizedName}" already exists.`); return; }
                        State.saveStateToHistory(); State.appState.wildcards[sanitizedName] = {}; State.saveState(true); UI.renderAll();
                    }
                }, true);
            },
            handleAddSubCategory(path) {
                const parentObject = this.getObjectByPath(path);
                const parentName = path.split('/').pop().replace(/_/g, ' ');
                UI.showNotification(`Add new item to "${parentName}".\nEnter name:`, true, (name) => {
                    if (name && name.trim()) {
                        const sanitizedName = name.trim().replace(/\s+/g, '_');
                        if (parentObject[sanitizedName]) { UI.showNotification(`"${sanitizedName}" already exists here.`); return; }
                        
                        UI.showNotification(`Is "${name}" a category folder or a wildcard list?\nType 'folder' or 'list'.`, true, (type) => {
                             State.saveStateToHistory();
                             if (type && type.trim().toLowerCase() === 'folder') {
                                parentObject[sanitizedName] = {};
                             } else {
                                parentObject[sanitizedName] = { instruction: '', wildcards: [] };
                             }
                             State.saveState(true); UI.renderAll();
                        }, true);
                    }
                }, true);
            },
            handleSearch(searchTerm) {
                const term = searchTerm.toLowerCase().trim();
                const container = UI.elements.container;

                container.querySelectorAll('.highlight').forEach(el => {
                    el.outerHTML = el.textContent;
                });
                container.querySelectorAll('[data-path]').forEach(el => el.style.display = 'block');
                
                if (!term) return;

                const matchedPaths = new Set();
                
                function findVisiblePaths(obj, currentPath) {
                    Object.keys(obj).forEach(key => {
                        const newPath = currentPath ? `${currentPath}/${key}` : key;
                        const data = obj[key];
                        const isLeaf = Array.isArray(data.wildcards);

                        if (isLeaf) {
                            if (data.wildcards.some(wc => wc.toLowerCase().includes(term))) {
                                matchedPaths.add(newPath);
                            }
                        } else {
                            if (findVisiblePaths(data, newPath)) {
                                matchedPaths.add(newPath);
                            }
                        }
                    });
                    return Array.from(matchedPaths).some(p => p.startsWith(currentPath));
                }
                
                findVisiblePaths(State.appState.wildcards, '');

                container.querySelectorAll('[data-path]').forEach(el => {
                    const path = el.dataset.path;
                    const isAncestorOrMatch = Array.from(matchedPaths).some(p => p.startsWith(path));

                    if (isAncestorOrMatch) {
                        el.style.display = 'block';
                        if (el.tagName === 'DETAILS') el.open = true;
                        
                        if(matchedPaths.has(path)) {
                            el.querySelectorAll('.chip span').forEach(span => {
                                const originalText = span.textContent;
                                if (originalText.toLowerCase().includes(term)) {
                                    const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                                    span.innerHTML = sanitize(originalText).replace(regex, '<span class="highlight">$1</span>');
                                }
                            });
                        }
                    } else {
                        el.style.display = 'none';
                    }
                });
            },
            handleDragStart(e) {
                const target = e.target.closest('[data-path]');
                if (target) {
                    this.draggedPath = target.dataset.path;
                    e.dataTransfer.setData('text/plain', this.draggedPath);
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => target.classList.add('dragging'), 0);
                }
            },
            handleDragOver(e) {
                e.preventDefault();
                const dropZone = e.target.closest('.content-wrapper');
                if (!dropZone || !this.draggedPath) return;

                const dropPath = dropZone.parentElement.dataset.path;

                if (this.draggedPath === dropPath || dropPath.startsWith(this.draggedPath + '/')) {
                    dropZone.classList.remove('drag-over');
                    return;
                }
                dropZone.classList.add('drag-over');
            },
            handleDragLeave(e) {
                const target = e.target.closest('.content-wrapper');
                if (target) {
                    target.classList.remove('drag-over');
                }
            },
            handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                const dropZone = e.target.closest('.content-wrapper');
                if (!dropZone || !this.draggedPath) return;
                
                dropZone.classList.remove('drag-over');
                const dropPath = dropZone.parentElement.dataset.path;

                if (this.draggedPath === dropPath || dropPath.startsWith(this.draggedPath + '/')) {
                    console.warn("Cannot drop an item into itself or its descendant.");
                    return;
                }

                const draggedKey = this.draggedPath.split('/').pop();
                const draggedObject = this.getObjectByPath(this.draggedPath);
                const sourceObject = this.getParentObjectByPath(this.draggedPath);
                const destinationObject = this.getObjectByPath(dropPath);

                if (destinationObject[draggedKey]) {
                    UI.showNotification(`An item named "${draggedKey.replace(/_/g, ' ')}" already exists in the destination.`);
                    return;
                }
                
                State.saveStateToHistory();
                delete sourceObject[draggedKey];
                destinationObject[draggedKey] = draggedObject;
                State.saveState(true);
                UI.renderAll();
            },
            handleDragEnd(e) {
                this.draggedPath = null;
                const draggingElement = document.querySelector('.dragging');
                if (draggingElement) draggingElement.classList.remove('dragging');
            },
            handleDownloadZip() {
                const zip = new JSZip();
                const addFilesToZip = (data, path) => {
                    Object.keys(data).forEach(key => {
                        const currentData = data[key];
                        const currentPath = path ? `${path}/${key}` : key;
                        const isLeaf = Array.isArray(currentData.wildcards);

                        if (isLeaf) {
                            const fileName = currentPath.replace(/\//g, '__') + '.txt';
                            zip.file(fileName, currentData.wildcards.join('\n'));
                        } else {
                            addFilesToZip(currentData, currentPath);
                        }
                    });
                };
                addFilesToZip(State.appState.wildcards, '');
                zip.generateAsync({ type:"blob" }).then(content => { const a = document.createElement('a'); a.href = URL.createObjectURL(content); a.download = "wildcard_collection.zip"; a.click(); URL.revokeObjectURL(a.href); });
            },
            handleExportState() { const stateString = JSON.stringify(State.appState, null, 2); const blob = new Blob([stateString], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "wildcard_generator_state.json"; a.click(); URL.revokeObjectURL(a.href); UI.showNotification('Application state exported.'); },
            handleImportState() { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = e => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = re => { try { const importedState = JSON.parse(re.target.result); if (importedState.systemPrompt && importedState.wildcards) { State.appState = importedState; State.saveState(true); State.clearHistory(); State.saveStateToHistory(); UI.renderAll(); UI.showNotification('State imported successfully.'); } else { UI.showNotification('Invalid state file format.'); } } catch (error) { UI.showNotification(`Error importing: ${error.message}`); } }; reader.readAsText(file); }; input.click(); },
            handleUndo() { if (State.undo()) { UI.renderAll(); UI.announce("Undo complete."); } },
            handleRedo() { if (State.redo()) { UI.renderAll(); UI.announce("Redo complete."); } },
            handleHelp() { UI.showNotification(`Welcome!\n\nKey Features:\n- Global Settings: Set API keys and choose your provider.\n- Recursive Categories: Add nested categories for better organization.\n- Drag & Drop: Reorder items by dragging them into category folders.\n- Inline Renaming: Click any title to rename it.\n- Generate More: Use AI to create new wildcards for any list.\n- Suggest Categories: Use AI to get ideas for new top-level categories.\n- Export/Import: Save and load your entire setup.\n- Undo/Redo: Revert or re-apply changes.`); }
        };

        document.addEventListener('DOMContentLoaded', () => App.init());
    </script>
</body>
</html>
